\section{Forward Process} % Seções são adicionadas para organizar sua apresentação em blocos discretos, todas as seções e subseções são automaticamente exibidas no índice como uma visão geral da apresentação, mas NÃO são exibidas como slides separados.


\begin{frame}
	\frametitle{Forward Process' Distribution}
	In order to produce signals that are pure Gaussian Noise, we need to sample from the following Normal Distribution which we will simply call forward ($\mathbf{q}$):
	\begin{align}
		\mathbf{x_t} &\sim  \mathcal{N}\big(\mathbf{\sqrt{\bar{\alpha}_t}\, x_0, (1 - \bar{\alpha}_t)I}\big) \\
		\mathbf{x_t} &\sim \mathbf{q(x_t|x_0)}
	\end{align}
	

	\begin{itemize}
		\item The forward process produces a noisy image $\mathbf{x_t}$by sampling from a normal distribution from which the mean is a function of the noisy-free image $\mathbf{x_0}$
	\end{itemize}
	
	\begin{figure}[H]
		\includegraphics[width=0.5\linewidth]{img/ddpm_forward.png}
	\end{figure}
	
	%----------------------------------------------------------------------------------------
\end{frame}


%----------------------------------------------------------------------------------------


\begin{frame}[fragile]
	\frametitle{Forward $\mathbf{q}$'s Parameters}
		\begin{python}[basicstyle=\ttfamily\tiny]
		class DDPMScheduler(nn.Module):
			def __init__(self, num_time_steps: int=1000):
			
				super().__init__()
				self.beta = torch.linspace(1e-4, 0.02, num_time_steps, requires_grad=False)
				
				# Alpha is defined as 1 - beta, i.e., 1 - Variance at step t
				alpha = 1 - self.beta
				
				# The variances are held constant during training, requires_grad = False
				self.alpha = torch.cumprod(alpha, dim=0).requires_grad_(False)
		
			def forward(self, t):
				return self.beta[t], self.alpha[t]
		\end{python}


	Given an input tensor $\mathbf{x_0}$ one can sample from $\mathbf{q(x_t|x_0)}$ by making the attribution:
		\begin{python}[basicstyle=\ttfamily\tiny]
		
		scheduler = DDPMScheduler()
		a = scheduler.alpha[t].view(batch_size,1,1,1)
		# Samples from forward q
		x = (torch.sqrt(a)*x) + (torch.sqrt(1-a)*e)
	\end{python}
	
\end{frame}